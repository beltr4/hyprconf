use std::fs;
use std::io::{self, Write};
use std::path::Path;

use crate::config::models::HyprlandConfig;
use crate::config::writer::sections;

use super::utils::CommentStyle;

pub struct ConfigWriter {
    config: HyprlandConfig,
    comment_style: CommentStyle,
}

impl ConfigWriter {
    pub fn new(config: HyprlandConfig) -> Self {
        Self {
            config,
            comment_style: CommentStyle::Hash,
        }
    }

    pub fn set_comment_style(&mut self, style: CommentStyle) {
        self.comment_style = style;
    }

    pub fn write_to_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
        let content = self.generate_config_content()?;
        fs::write(path, content)?;
        Ok(())
    }

    pub fn generate_config_content(&self) -> io::Result<String> {
        let mut buffer = Vec::new();
        
        // Write a header comment
        writeln!(buffer, "{} This file was generated by HyprConf", self.comment_style.prefix())?;
        writeln!(buffer, "{} Any manual changes may be overwritten", self.comment_style.prefix())?;
        writeln!(buffer)?;
        
        // Write all config sections
        self.write_general_section(&mut buffer)?;
        self.write_decoration_section(&mut buffer)?;
        self.write_animations_section(&mut buffer)?;
        self.write_input_section(&mut buffer)?;
        self.write_gestures_section(&mut buffer)?;
        self.write_group_section(&mut buffer)?;
        self.write_misc_section(&mut buffer)?;
        self.write_binds_section(&mut buffer)?;
        self.write_xwayland_section(&mut buffer)?;
        self.write_opengl_section(&mut buffer)?;
        self.write_render_section(&mut buffer)?;
        self.write_cursor_section(&mut buffer)?;
        self.write_dwindle_section(&mut buffer)?;
        self.write_master_section(&mut buffer)?;
        self.write_debug_section(&mut buffer)?;
        
        // Write monitors
        self.write_monitors(&mut buffer)?;
        
        // Write devices
        self.write_devices(&mut buffer)?;
        
        // Write window rules
        self.write_window_rules(&mut buffer)?;
        
        // Write workspace rules
        self.write_workspace_rules(&mut buffer)?;
        
        // Write layer rules
        self.write_layer_rules(&mut buffer)?;
        
        // Write variables
        self.write_variables(&mut buffer)?;
        
        // Write environment variables
        self.write_environment_variables(&mut buffer)?;
        
        // Write autostart programs
        self.write_autostart_programs(&mut buffer)?;
        
        // Write bezier curves
        self.write_bezier_curves(&mut buffer)?;
        
        // Write submap definitions
        self.write_submap_definitions(&mut buffer)?;
        
        // Write ecosystem section
        self.write_ecosystem_section(&mut buffer)?;
        
        // Write experimental section
        self.write_experimental_section(&mut buffer)?;
        
        // Write permissions
        self.write_permissions(&mut buffer)?;
        
        Ok(String::from_utf8(buffer).unwrap())
    }
    
    fn write_general_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::general::write_section(buffer, &self.config.general, &self.comment_style)
    }
    
    fn write_decoration_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::decoration::write_section(buffer, &self.config.decoration, &self.comment_style)
    }
    
    fn write_animations_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::animations::write_section(buffer, &self.config.animations, &self.comment_style)
    }
    
    fn write_input_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::input::write_section(buffer, &self.config.input, &self.comment_style)
    }
    
    fn write_gestures_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::gestures::write_section(buffer, &self.config.gestures, &self.comment_style)
    }
    
    fn write_group_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::group::write_section(buffer, &self.config.group, &self.comment_style)
    }
    
    fn write_misc_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::misc::write_section(buffer, &self.config.misc, &self.comment_style)
    }
    
    fn write_binds_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::binds::write_section(buffer, &self.config.binds, &self.comment_style)
    }
    
    fn write_xwayland_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::xwayland::write_section(buffer, &self.config.xwayland, &self.comment_style)
    }
    
    fn write_opengl_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::opengl::write_section(buffer, &self.config.opengl, &self.comment_style)
    }
    
    fn write_render_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::render::write_section(buffer, &self.config.render, &self.comment_style)
    }
    
    fn write_cursor_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::cursor::write_section(buffer, &self.config.cursor, &self.comment_style)
    }
    
    fn write_dwindle_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::dwindle::write_section(buffer, &self.config.dwindle, &self.comment_style)
    }
    
    fn write_master_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::master::write_section(buffer, &self.config.master, &self.comment_style)
    }
    
    fn write_debug_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        sections::debug::write_section(buffer, &self.config.debug, &self.comment_style)
    }
    
    fn write_monitors(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for monitor in &self.config.monitors {
            writeln!(buffer, "monitor = {},{},{},{}", 
                monitor.name,
                monitor.resolution,
                monitor.position,
                monitor.scale
            )?;
            
            // Additional monitor properties if present
            if let Some(transform) = monitor.transform {
                writeln!(buffer, "monitor = {}, transform, {}", monitor.name, transform)?;
            }
            
            if let Some(mirror) = &monitor.mirror {
                writeln!(buffer, "monitor = {}, mirror, {}", monitor.name, mirror)?;
            }
            
            if let Some(bitdepth) = monitor.bitdepth {
                writeln!(buffer, "monitor = {}, bitdepth, {}", monitor.name, bitdepth)?;
            }
            
            if let Some(color_management) = &monitor.color_management {
                writeln!(buffer, "monitor = {}, colorspace, {}", monitor.name, color_management)?;
            }
            
            if let Some(sdr_brightness) = monitor.sdr_brightness {
                writeln!(buffer, "monitor = {}, sdr_brightness, {}", monitor.name, sdr_brightness)?;
            }
            
            if let Some(sdr_saturation) = monitor.sdr_saturation {
                writeln!(buffer, "monitor = {}, sdr_saturation, {}", monitor.name, sdr_saturation)?;
            }
            
            if let Some(vrr) = monitor.vrr {
                writeln!(buffer, "monitor = {}, vrr, {}", monitor.name, vrr)?;
            }
            
            if monitor.disable {
                writeln!(buffer, "monitor = {}, disable", monitor.name)?;
            }
            
            if let Some(reserved_area) = monitor.reserved_area {
                writeln!(buffer, "monitor = {}, reserved, {},{},{},{}", 
                    monitor.name, 
                    reserved_area.0, 
                    reserved_area.1, 
                    reserved_area.2, 
                    reserved_area.3
                )?;
            }
        }
        Ok(())
    }
    
    fn write_devices(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for device in &self.config.devices {
            writeln!(buffer, "device {{")?;
            writeln!(buffer, "    name = {}", device.name)?;
            
            if let Some(sensitivity) = device.sensitivity {
                writeln!(buffer, "    sensitivity = {}", sensitivity)?;
            }
            
            if let Some(accel_profile) = &device.accel_profile {
                writeln!(buffer, "    accel_profile = {}", accel_profile)?;
            }
            
            // Add all the other device properties here
            
            writeln!(buffer, "}}")?;
        }
        Ok(())
    }
    
    fn write_window_rules(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for rule in &self.config.window_rules {
            write!(buffer, "windowrule = {},", rule.rule)?;
            
            write!(buffer, "{}", rule.value)?;
            
            for param in &rule.parameters {
                write!(buffer, ",{}", param)?;
            }
            
            writeln!(buffer)?;
        }
        Ok(())
    }
    
    fn write_workspace_rules(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for rule in &self.config.workspace_rules {
            writeln!(buffer, "workspace = {}", rule.workspace)?;
            
            for (key, value) in &rule.rules {
                writeln!(buffer, "    {} = {}", key, value)?;
            }
        }
        Ok(())
    }
    
    fn write_layer_rules(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for rule in &self.config.layer_rules {
            write!(buffer, "layerrule = {},{}", rule.rule, rule.target)?;
            
            if let Some(value) = &rule.value {
                write!(buffer, ",{}", value)?;
            }
            
            writeln!(buffer)?;
        }
        Ok(())
    }
    
    fn write_variables(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for (name, value) in &self.config.variables {
            writeln!(buffer, "${} = {}", name, value)?;
        }
        Ok(())
    }
    
    fn write_environment_variables(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for (name, value) in &self.config.environment_variables {
            writeln!(buffer, "env = {}={}", name, value)?;
        }
        Ok(())
    }
    
    fn write_autostart_programs(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for program in &self.config.autostart_programs {
            writeln!(buffer, "exec-once = {}", program)?;
        }
        Ok(())
    }
    
    fn write_bezier_curves(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for (name, value) in &self.config.bezier_curves {
            writeln!(buffer, "bezier = {},{}", name, value)?;
        }
        Ok(())
    }
    
    fn write_submap_definitions(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for (name, binds) in &self.config.submap_definitions {
            writeln!(buffer, "submap = {}", name)?;
            
            for bind in binds {
                write!(buffer, "bind = {},{}", bind.modifiers, bind.key)?;
                
                for dispatcher in &bind.dispatchers {
                    write!(buffer, ",{}", dispatcher)?;
                }
                
                if !bind.arg.is_empty() {
                    write!(buffer, ",{}", bind.arg)?;
                }
                
                if let Some(flags) = &bind.flags {
                    write!(buffer, ",{}", flags)?;
                }
                
                writeln!(buffer)?;
            }
            
            writeln!(buffer, "submap = reset")?;
        }
        Ok(())
    }
    
    fn write_ecosystem_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        writeln!(buffer, "ecosystem {{")?;
        writeln!(buffer, "    no_update_news = {}", self.config.ecosystem.no_update_news)?;
        writeln!(buffer, "    no_donation_nag = {}", self.config.ecosystem.no_donation_nag)?;
        writeln!(buffer, "    enforce_permissions = {}", self.config.ecosystem.enforce_permissions)?;
        writeln!(buffer, "}}")?;
        Ok(())
    }
    
    fn write_experimental_section(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        writeln!(buffer, "experimental {{")?;
        writeln!(buffer, "    xx_color_management_v4 = {}", self.config.experimental.xx_color_management_v4)?;
        writeln!(buffer, "}}")?;
        Ok(())
    }
    
    fn write_permissions(&self, buffer: &mut Vec<u8>) -> io::Result<()> {
        for permission in &self.config.permissions {
            writeln!(buffer, "permission = {}:{}:{}", 
                permission.path_regex,
                permission.permission_type,
                permission.mode
            )?;
        }
        Ok(())
    }
}